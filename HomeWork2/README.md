### Архитектурная ката [Going Green](http://nealford.com/katas/kata?id=GoingGreen "Going Green")

#### 1. **Кейс**

За основу взят кейс из [предыдущего домашнего задания](https://github.com/Anton-Grebenkin/GoingGreen/tree/main/HomeWork1) 

#### 2. **Модель предметной области**
Выделены основные сущности:
- Customer (пользователь, который хочет сдать устройство)
- Device Type (тип устройства с основной информацией)
- Application (заявка клиента на сдачу устройства)
- Evaluation Rule (правило оценки типов устройств)
- Quoting Rule (правило ценообразования типов устройств)
- Shipment (данные об отправках устройств и коробок)
- Payment (информация о платежах)
- Evaluation (конечная оценка устройства на складе)

![enter image description here](https://github.com/Anton-Grebenkin/GoingGreen/blob/main/HomeWork2/photo_2025-09-14_19-01-15.jpg)

#### 3. **Функциональная декомпозиция**
Приведу два примера декомпозиции: по бизнес возможностям и по клиентскому пути
#### 3.1. **Декомпозиция по бизнес возможностям**
1.  **Каталог электроники (Device Catalog)**: Управляет списком принимаемых типов устройств (`Device Type`). Отвечает за добавление, архивацию и удаление типов.
2.  **Ценообразование (Quoting Engine)**: Рассчитывает первоначальную стоимость на основе  `Equipment Type`  и данных от клиента. Содержит  `Quoting Rules`.
3.  **Управление клиентами (Customer Management)**: Регистрация и ведение данных о пользователях.
4.  **Логистика (Logistics)**: Управляет отправкой коробок клиентам (`Shipment`) и регистрацией полученных устройств.
5.  **Оценка (Evaluation Service)**: Проводит техническую проверку полученного устройства. Содержит  `Evaluation Rules`  и создает  `Evaluation`.
6.  **Платежи (Payments)**: Отвечает за формирование и отправку платежей (`Payment`) клиентам.
7.  **Управление заявками клиентов (Applications)**: Отвечает за создание заявки и управление ее статусом.

![enter image description here](https://github.com/Anton-Grebenkin/GoingGreen/blob/main/HomeWork2/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%B1%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.drawio%20(4).png)
#### 3.2. **Декомпозиция по клиентскому пути**
1.  **Создание заявки (Applications)**: Всё, что происходит до отправки устройства клиентом. Включает в себя:
    -   Работу с каталогом устройств.
    -   Расчет цены.
    -   Взаимодействие с клиентом через UI.
    -   Регистрацию клиента.
2.  **Операционная обработка (Operations)**: Всё, что происходит на складе. Включает в себя:
    -   Логистику и приемку посылок.
    -   Проведение технической оценки.
    -   Пересмотр  цены  при необходимости.
3.  **Пост-обработка и оплата (Post-Processing)**: Всё, что происходит после финального согласования цены. Включает в себя:
    -   Проведение выплат.
    -   Передачу устройства на продажу или утилизацию.

![enter image description here](https://github.com/Anton-Grebenkin/GoingGreen/blob/main/HomeWork2/%D0%94%D0%B8%D0%B0%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B0%20%D0%B1%D0%B5%D0%B7%20%D0%BD%D0%B0%D0%B7%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F.drawio%20(5).png)

#### 4. Возможные сценарии изменений системы
1.  Добавление нового способа оплаты. (вероятность высокая)
В первом случае изменения затронут Payments Service, который отвечает за платежи. Во втором придется менять Post-Processing Service, который содержит логику помимо оплат. Это может вызвать проблемы.
2.  Добавление нового типа устройства. (вероятность высокая)
В первом случае изменения преется вносить в узкоспециализированные сервсиы: Device Catalog, Quoting Engine, Evaluation Service. Во втором случае логика размазывается по всем трем сервисам, что сложнее тестировать
3.  Добавить программу лояльности для клиентов. (вероятность высокая)
Допустим бизнес захочет добавить бонусную систему или уровни клиента, в зависимости от которых будет увеличиваться выплата. Во втором случае придется менять один компонент Post-Processing Service, в первом случае изменения затронут несколько сервисов, возможно придется добавлять новый сервис.

#### 4. Вывод
В первом случае сервисы имеют высокий Cohesion, каждый компонент отвечает за одну бизнес функцию. во втором случае компоненты содержат разнородную логику.
В первом случае сервисы имеют низкий Coupling, изменения в одном компоненте не затрагивают другие. Во втором случае для изменний нужно затронуть все компоненты.
Первый вариант лучше модифицируется. Он выделяет наиболее изменчивые части системы (Каталог, Ценообразование, Оценка) в отдельные компоненты. Это позволяет локализовать изменения.
Второй вариант лучше подходит для оптимизации отдельных этапов пользовательского пути, но проигрывает в сквозных изменниях
